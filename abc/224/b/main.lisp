;; (let ((rl (read-line)))
;;   (format t "~s~%" (uiop:split-string rl :separator " "))
;;   (format t "~a~%" (mapcar #'parse-integer (uiop:split-string rl :separator " ")))
;;   )
;; nを読み取って、n回行を読み取る
;; (let ((n (parse-integer (read-line))))
;;   (format t "~a~%" (count-if #'(lambda (x) (string= x "Takahashi"))
;; 		   (loop for x from 0 to (1- n)
;; 			 collect (read-line))))
;;   )

(defun take (n l)
  (if (or (= n 0) (not l))
      '()
      (cons (car l) (take (1- n) (cdr l)))))

(defun drop (n l)
  (if (or (= n 0) (not l))
      l
      (drop (1- n) (cdr l))))

(defun run (h w wl)
  (loop for i1 from 0 to (- h 2)
	append (loop for i2 from (1+ i1) to (1- h)
		     append (loop for j1 from 0 to (- w 2)
				  append (loop for j2 from (1+ j1) to (1- w)
						collect (<= (+ (nth j1 (nth i1 wl))
								 (nth j2 (nth i2 wl)))
							      (+ (nth j1 (nth i2 wl))
								 (nth j2 (nth i1 wl)))
							      )
						)
				  )
		     )
	)
  )

(let* ((hw (mapcar #'parse-integer (uiop:split-string (read-line) :separator " ")))
       (h (nth 0 hw))
       (w (nth 1 hw))
       (wl (loop for x from 0 to (1- h)
		 collect (mapcar #'parse-integer (uiop:split-string (read-line) :separator " ")))))
  (if (every #'identity (run h w wl))
      (format t "Yes~&")
      (format t "No~&"))
  )

;; 処理系ごとの離脱用のコード。これがないとエラーが出る
#+sbcl (sb-ext:exit)
#+ccl (ccl:quit)
#+ecl (ext:quit)
#-(or sbcl ccl ecl) (quit)
